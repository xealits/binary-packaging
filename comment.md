Let's consider 2 packages: `d` and `s`.
And `d` depends on the package `s`.
Some module in `d` literally loads stuff from `s` with:

    from s import foo

Apparently, loading it depends on where the current working directory of interpreter is.

And, as tests show, really nothing default (without changing the code in d itself)
can make it load `s` from the package's own directory.
Everything is loaded with respect to current interpreter session -- pythonpath, sys.path its' working directory etc.
(So, dynamic scoping instead of lexical.)

Thus, the first idea does not apply to Python...


# Interpreter session based packaging

Итак с созданием окружения для пакетов неудача.
Питон грузит всё динамически, всё в сессии интерпретатора.
Нужно создавать окружение не для пакета, а для интерпретатора

* Надо проверить откуда втягиваются `.so` файлы для `ctypes`.

* И раз импорт завязан на интерпретатор, мб стоит делать модуль для пакетов в самом питоне?
  Затем как-то расширить его на баш а-ля `virtualenv`.




# Name of the program

"Content packager"?
("As easy as copy" like.)
Binary packager?





# Задача, в линуксовых ELF бинарниках и в питоне

Зависимость: "что-где" ("что-как") пара.
Линковщик/процедура разбора зависимостей в линуксе и в питоне.
"Общая задача" (на сколько возможно) и реализации в процедурах линукса и питона.

## Linux, so

Суть в том, что согласно инфе в динамической секции ELF
линковщик находит пути в файловой системе к нужным бинарникам зависимостей.
   (Это делается по:
   имени зависисмости, если оно содержит слеш,
   по переменной окружения LD_LIBRARY_PATH,
   путям в RUNPATH переменной хедера
   и наконец в стандартных директориях (/lib, /usr/lib, /lib/x86_64-gnu-linux/..),
   плюс где-то ещё кеш линковщика между этими пунктами.
   Но это не суть.)
Найдя путь к зависимости, линковщик втягивает её и разбирает её зависимости.
При этом есть один нюанс:
если найденый файл -- симлинк,
тогда линковщик следует по симлинку до реального файла
и разбор зависимостей этого бинарника происходит относительно пути реального файла.
Что сказывается в случае разбора по слешеному имени зависимости, или наличию $ORIGIN в RUNPATH.
...Так что не замутишь калейдоскопа зависимостей фермой симлинков...




# Требования

* полное окружение зависимостей и корректный разбор при простом копировании всех бинарников в 1 директорию

* простая и доступная работа в локальном пространстве юзера, без привилегий
  всё должно быть настолько просто, чтобы это можно было делать вручную, а уже потом автоматизировать

* поддержка разных версий пакетов/бинарников в хранилище менеджера пакетов (хеши содержимого)

* сборка окружений из доступных пакетов ссылками/наиболее лёгким методом, поменьше копирования,
  т.е. по возможности символьными ссылками, так как они могут указывать на разные девайсы/файловые системы
  (поначалу прийдётся копировать...)

* "зависимости простых файлов"
  зависимость от наличия некоего простого текстового файла?
  (разбор пересечений таких зависимостей?)

* интерфейс-ссылка в собранный граф зависимостей

* рабочее пространство (build/dev)

* дополнительные файлы пакета: документация, перевод в разные языки и т.п.

* безопасность с использованием хешей содержимого (с динамической секцией или без?)


# Решения

Пара корректировок:

1. стандартный пакет софта это не 1 бинарник,
   а целый набор, возможно с внутренними зависимостями,
   плюс документация и прочие не-ELF файлы;
   т.е. и подход должен быть как к некоторому определению окружения

2. "зависимости простых файлов" нужно ещё продумать и как-то формализовать,
   для них должна быть своя "секция зависимостей и путей поиска",
   в соответствии с которыми и надо делать решение;
   например документация, как ищются страницы man,
   если в PATH появилась новая версия бинарника,
   то где, по какой переменной, должна находится соотв. новая man страница?

3. предыдущим двум пунктам должно подходить определение окружения из бинарников и прочих файлов;
   к бинарнику и зависимостям где-то на файловой системе должна вести некая $PATH переменная,
   точно так же и с ман-страницами;
   это часть "где" из канбановской схемы
   (она может определяться как производителем так и заказчиком, как тут и получилось)


## Решение 1 для ELF, на ручное и fish исполнение

Нужно патчить `RUNPATH` во всех элфах на `$ORIGIN:$ORIGIN/<elfname>_deps/:$ORIGIN/common_libs`.
Делать хеши этих бинарников и именовать их:
`name,version,hash` -- с надеждой что запятая никем не используется.
(Плюс, надо почитать про "семантические версии", используемые в Julia.)
Складывать эти файлы в некую директорию `store`, или держать в интернете.
Они, с их именами, не используемы и не должны быть.
Их можно как-то сортировать, мб по пакетам, мб по формату (ELF) или функции.. Поначалу можно всё в одну кучу.
Из этих `RUNPATH`-ed бинарников можно собирать какие угодно окружения.
Причём, всё просто и вручную. Можно начать пробовать организацию окружений, ответвления с shadowing.
Использование алиасных симссылок на окружения для атомарных апгрейдов:
меняя направление ссылки можно изменить зависимости всех использующих её бинарников.

Т.е. на этом установка пакета:

    install bin.elf [where] [--libs=a,b,c]

--- смотрит нет ли уже этого бинарника в `where` (или в неком default месте)
(тут аспект импользования, так что имя файла = имя бинарника, без хешей, с версией, а имя без версии -- симссылка),
если нет то достаёт соотв. бинарник из `store` директории (или из интернета, торрента),
выбирает его по указаному имени, версии, хешу или части этого всего,
просматривает зависимости,
(!) сравнивает их с ELF в неких известных (`--libs=a,b,c`) директориях-окружениях для общеиспользуемых, стандартных библиотек,
если там что-то есть из нужного, то на него делается симссылка, если нет, то файл зависимости копируется из `store`
и всё помещается в `where` (или default место)
и *добавляет `where` в `$PATH`*. (Добавление в `$PATH` это новая процедура, её можно и отельно делать.)

!! Нельзя просто сложить бинарники в рабочую директорию без хешей и версий -- нужны какие-то обратные ссылки,
от рабочего бинарника в `$PATH` к его `имени,версии,хешу`. !!
Симлинки не годятся -- нужно чтоб реальные файлы бали расположены в нужной файловой иерархии.
Можно делать хардссылки, но это не надёжно.
-- (Вообще-то хардссылки будут необходимы для всяких libc внутри тысяч `foolib_deps/`...) <--- !!!!!! таки понядобятся какие-то стандартные стандартные директории
-- Или директории-окружения со стандартными библиотеками (libc, linux, ld), в которые делаются симлинки.
-- TODO: проверить ~/ $HOME директории в RUNPATH? Нужно `LD_LIBRARY_PATH` после `RUNPATH`.
-- ! можно просто добавить `$ORIGIN/common_libs/` в `RUNPATH`; общие зависимости целого окружения и зависимости для каждого бинарника.
Если копировать, меняя имя, то теряется версия, но хеш можно узнать по содержимому файла и найти его потом в `store`.
-- TODO: Нужно разобраться что нужно от версии/хеша и прочей инфы о бинарнике?
-- в принципе, должна быть возможно узнать всё о файле по его хешу:
-- можно хранить доп. инфу в `store` версии, из каких пакетов какие файлы/хеши взяты и т.п.

Возникают вопросы, если `where` уже есть в `$PATH`, а также если там где-то уже есть запрошеный бинарник..
Для начала можно решить так:
бинарник в любом случае всё равно ставится в `where`,
если `where` есть в `$PATH`, то ничего страшного, проблема мб если впереди него уже есть некая версия этого бинарника,
если такой бинарник есть где-то в `$PATH`, то об этом надо сообщить (с его версией и хешем),
если этот бинарник перекрывает устанавливаемый, то об этом сообщить дополнительно.

--- т.е. получается, что есть директории-окружения, сборки по RUNPATH,
в них могут быть симлинки в другие директории-окружения (особенно со стандартными библиотеками),
сверх этого работает `LD_LIBRARY_PATH` и стандартные директории в руте -- на подхвате.
Директории-окружения и симлинки между ними -- механизмы этого "менеджера пакетов".
Симлинки ничего принципиально не меняют в дереве зависимостей -- его также можно разобрать и хешить.
Просто уменьшают кол-во копирования. И добавляют проблем с организацией всех этих директорий.

Пути в `$PATH` это окружение программиста-пользователя -- оно как-то аналогично директориям-окружений и их симлинкам?
По идее, нет -- это пути к исполнительным файлам, зависимости тут не важны.
Но с точки зрения элф файлов тут есть аналогия:
есть директории-окружения, собранные из runpath-ed файлов,
и они используются по симссылке в такую директорию.

Надо разобрать как идёт поиск ман страниц и добавить их в систему.
Схема такая же: собираешь окружение в некой директории (тут просто копируешь туда ман-страницу),
добавляешь директорию в `$MAN_PATH`.
(Но это ещё нужно как-то синхронизовать с бинарниками..)

В Питоне делается всё то же самое, только внутри Питона (а не линукса, хотя в линуксе фс-часть должна быть готова).






